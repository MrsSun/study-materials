#### 内存模型
![img_5.png](img_5.png)
### 内存模型特征
![img_4.png](img_4.png)

### java 线程实现


### Java线程状态
![img_6.png](img_6.png)

### java 创建线程的方式
1. 继承thread
2. 实现Runnable
3. 实现callable

### wait与sleep方法区别
1、来自不同的类

这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object类。

sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。


2、有没有释放锁(释放资源)

最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。

sleep不出让系统资源；wait是进入线程等待池等待，出让系统资源，其他线程可以占用CPU。一般wait不会加时间限制，因为如果wait线程的运行资源不够，再出来也没用，要等待其他线程调用notify/notifyAll唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。sleep(milliseconds)可以用时间指定使它自动唤醒过来，如果时间不到只能调用interrupt()强行打断。

Thread.Sleep(0)的作用是“触发操作系统立刻重新进行一次CPU竞争”。

sleep是线程被调用时，占着cpu去睡觉，其他线程不能占用cpu，os认为该线程正在工作，不会让出系统资源，wait是进入等待池等待，让出系统资源，其他线程可以占用cpu，一般wait不会加时间限制，因为如果wait的线程运行资源不够，再出来也没用，要等待其他线程调用notifyall方法唤醒等待池中的所有线程，才会在进入就绪序列等待os分配系统资源，
sleep是静态方法，是谁掉的谁去睡觉，就算是在main线程里调用了线程b的sleep方法，实际上还是main去睡觉，想让线程b去睡觉要在b的代码中掉sleep

sleep(100L)是占用cpu，线程休眠100毫秒，其他进程不能再占用cpu资源，wait（100L）是进入等待池中等待，交出cpu等系统资源供其他进程使用，在这100毫秒中，该线程可以被其他线程notify，但不同的是其他在等待池中的线程不被notify不会出来，但这个线程在等待100毫秒后会自动进入就绪队列等待系统分配资源，换句话说，sleep（100）在100毫秒后肯定会运行，但wait在100毫秒后还有等待os调用分配资源，所以wait100的停止运行时间是不确定的，但至少是100毫秒。

就是说sleep有时间限制的就像闹钟一样到时候就叫了，而wait是无限期的除非用户主动notify


3、使用范围不同

wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用
synchronized(x){
x.notify()
//或者wait()
}


4、是否需要捕获异常

sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常。
### 什么是线程安全？
当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，
调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。

### 线程安全的实现方式？
1. 互斥同步： 如通过加锁的方式（synchronized），保证多个线程访问同一个共存数据时，只能共享数据同一时刻只能被一个线程使用；
2. 非阻塞同步：不管三七二十一先执行操作，操作失败再进行补偿措施，就是不断重试，直到共享数据没有竞争执行成功为止；</br>
   这个依赖硬件设备，需要检测冲突和执行操作保证原子性；
   常用的java类库：譬如J.U.C包里面的整数原子类，其中的compareAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS操作来实现。
3. 无同步方案： 线程本地存储（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。
   如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。如threadlocal

### synchronized 实现与锁优化
1. 自旋锁：在JDK 6中对自旋锁的优化，引入了自适应的自旋。自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。
2. 锁消除：如果一段代码中，堆上的所有数据都不会逃逸出去被其他线程访问到，那我们就可以把它们当成栈上的数据对待，认为他们是线程私有的；
3. 锁粗化：虚拟机如果探测到一堆零碎的操作对同一个对象加锁，将会把加锁同步的范围粗化，加到整个操作序列的外部；
4. 偏向锁：建立在绝大数时间锁对象只会被一个线程所持有；
   当线程需要获取锁对象的时候，设置对象头的锁标志，再使用cas操作将自己的线程ID记录到对象头markWord中
   当出现锁竞争，偏向锁模式立刻撤销，如果对象未锁定（即持有锁的线程已结束运行，或者退出了同步代码块）则撤销偏向锁模式，
   如果对象已锁定（即持有锁的线程还未退出同步代码块）则升级为轻量级锁；
5. 轻量级锁：建立在多个线程交替进行
   首先会在当前栈帧中创建锁记录lock record，然后将对象头的mardword拷贝放到lr中，再使用cas操作将对象头markword更新为指向lockReocrd的指针，如果更新成功则表示获取锁成功；
6. 锁升级的过程：
   I. 首先判断能否使用偏向锁，如果开启偏向锁&锁对象未生成hashcode，则可偏向；
   II. 检查锁对象MarkWord中的threadId是否是当前线程，是的话则直接执行；否的话使用cas操作，将自己的threadId更新到markWord中；更新成功表示获取了锁对象；
   III. 如果cas更新失败，表示出现锁竞争，偏向模式立刻结束。如果对象未被锁定，则直接撤销偏向锁；如果锁对象已被锁定，则将升级锁模式为轻量级锁；
   IV. 如果超过两个以上的线程出现锁竞争，则升级轻量级锁模式为重量级锁；


### volatile实现
![img_7.png](img_7.png)

![img_8.png](img_8.png)
### 双层锁校验实现单例模式？原因？
![img_10.png](img_10.png)
![img_9.png](img_9.png)
### JUC实现